---
title: "Data analysis"
output: 
  html_notebook
---


# Hypotheses

We wish to test hypotheses relating to how routine activities of school
students influence crime in surrounding areas. Specifically, if school students'
activities cause increases in crime, we would expect:

  * H1: high/middle schools to be associated with more violence at schools times 
    on school weekdays but not on vacation weekdays or at non-school times,
  * H2: high/middle schools to be associated with more violence but elementary
    schools not to be,
  * H3: high schools to be associated with more violence on streets and against 
    some types of business but not more violence in dwellings,


# Read data

The data are already in the required format because data cleaning has been done,
so they can just be read directly from the RDS file.

```{r}
data <- read_rds("../analysis_data/blockgroup_data.Rds") %>% 
	glimpse()
```


# Check data

We can check in detail that the data meets our expectations. This is done in 
this file rather than the data cleaning file in case any problems have been
introduced while saving and loading the data as a CSV.

```{r}
data %>% 
	
	# characters
	assert(is.character, geoid) %>% 
	assert(not_na, geoid) %>% 
	print_comment("👍 geoid is a character with no NA values") %>% 

	# characters with specific values
	assert(is.character, city_name) %>% 
	assert(in_set(cities$name), city_name) %>% 
	assert(not_na, city_name) %>% 
	print_comment("👍 city_name is a character, all values are valid CODE cities",
								"with no NA values") %>% 
	assert(is.character, public_location) %>% 
	assert(in_set("public", "private", "other"), public_location) %>% 
	assert(not_na, public_location) %>%
	print_comment("👍 public_location is a character, all values are valid with",
								"no NA values") %>% 

	# positive integers
	assert(is.integer, count, schools, students, private_elementary_schools, 
				 private_secondary_schools, public_elementary_schools, 
				 public_secondary_schools, private_elementary_students, 
				 private_secondary_students, public_elementary_students, 
				 public_secondary_students, elementary_schools, secondary_schools, 
				 elementary_students, secondary_students, pop_total) %>% 
	assert(within_bounds(0, Inf), count, schools, students, 
				 private_elementary_schools, private_secondary_schools, 
				 public_elementary_schools, public_secondary_schools, 
				 private_elementary_students, private_secondary_students, 
				 public_elementary_students, public_secondary_students, 
				 elementary_schools, secondary_schools, elementary_students, 
				 secondary_students, pop_total) %>% 
	assert(not_na, count, schools, students, private_elementary_schools, 
				 private_secondary_schools, public_elementary_schools, 
				 public_secondary_schools, private_elementary_students, 
				 private_secondary_students, public_elementary_students, 
				 public_secondary_students, elementary_schools, secondary_schools, 
				 elementary_students, secondary_students, pop_total) %>% 
	print_comment("👍 count, schools, students, private_elementary_schools,", 
								"private_secondary_schools, public_elementary_schools,",
								"public_secondary_schools, private_elementary_students,", 
								"private_secondary_students, public_elementary_students,", 
								"public_secondary_students, elementary_schools,", 
								"secondary_schools, elementary_students, secondary_students",
								"and pop_total are positive integers with no NA values") %>% 
	
	# doubles
	assert(is.double, index_disadvantage, index_mobility, index_ethnic,
				 perc_teen_sc, prop_zoned_commercial_sc) %>%
	assert(not_na, index_disadvantage, index_mobility, index_ethnic,
				 perc_teen_sc, prop_zoned_commercial_sc) %>%
	print_comment("👍 index_disadvantage, index_mobility, index_ethnic,",
								"perc_teen_sc and prop_zoned_commercial_sc are doubles with no",
								"NA values") %>% 

	# doubles between zero and one
	assert(is.double, prop_developed, land_cover_prop_22, land_cover_prop_23,
				 land_cover_prop_24, prop_zoned_commercial) %>%
	assert(within_bounds(0, 1), prop_developed, land_cover_prop_22,
				 land_cover_prop_23, land_cover_prop_24, prop_zoned_commercial) %>%
	print_comment("👍 prop_developed, land_cover_prop_22, land_cover_prop_23,",
								"land_cover_prop_24 and prop_zoned_commercial are doubles",
								"between 0 and 1 with no NA values") %>% 

	# positive doubles
	assert(is.double, area_land, area_water, count_lag) %>% 
	assert(within_bounds(0, Inf), area_land, area_water, count_lag) %>% 
	assert(not_na, area_land, area_water, count_lag) %>% 
	print_comment("👍 area_land, area_water, pop_density and count_lag are",
								"positive doubles with no NA values") %>% 

	# factors
	assert(is.factor, crime_type, period) %>% 
	assert(not_na, crime_type, period) %>%
	print_comment("👍 crime_type and period are factors with no NA values") %>% 
	# assert(in_set("non-school day, school time", "school day, non-school time", 
	# 							"non-school day, non-school time", "school day, school time"), 
	# 			 period) %>% 
	# print_comment("👍 all values of period are valid") %>% 

	# logicals
	assert(is.logical, school_day, school) %>% 
	# assert(not_na, school_day, school_time, school) %>% 
	print_comment("👍 school_day and school are logical with no NA",
								"values") %>% 

	glimpse()
```


# Select a model type

Since the dependent variable is a count of crimes, we expect the data to have an
overdispersed Poisson (i.e. negative binomial) distribution. This can be checked
visually and by calculating the ratio of the variance of the dependent variable
to the mean.

```{r}
data %>% 
	mutate(label = str_replace_all(period, ", ", "\n")) %>% 
	ggplot() + geom_histogram(aes(count), bins = 100) + 
	facet_grid(cols = vars(crime_type, school_day), rows = vars(date_hour)) + 
	theme_minimal() +
	theme(strip.text.y = element_text(angle = 0))
```

The histograms suggest a Poisson-distributed response variable. We can check
the var/mean ratio to see if it is over-dispersed.

```{r}
data %>% 
	group_by(crime_type) %>% 
	summarise(cov = var(count) / mean(count))
```

We can see the variance is much greater than the mean, so (as expected) the 
response variable is overdispersed.

The histograms suggest some outlier blockgroups. We can identify these:

```{r}
data %>% 
	filter(count > 300, prop_zoned_commercial < 0.5)
```



# Descriptive analysis

## Schools

```{r}
data %>% 
	group_by(city_name, school) %>% 
	summarise(n = n()) %>% 
	spread(school, n) %>% 
	mutate(prop_with_schools = round(`TRUE` / (`TRUE` + `FALSE`), digits = 3))
```


# Test assumptions

In the models we control for disadvantage, population turnover, ethnic 
heterogeneity and the proportion of the population who are teenagers. To see if 
this is necessary, we can test whether places with schools are different in 
these respects to places without schools.

```{r}
map_df(
	c("index_disadvantage", "index_mobility", "index_ethnic", "perc_teen_sc", 
		"prop_developed", "prop_zoned_commercial"), 
	function (x) {
		wilcox.test(as.formula(paste(x, "~ school")), data = data) %>% 
			tidy() %>% 
			mutate(test = paste("Wilcoxcon: ", x, "~ school"))
	}) %>%
	select(test, statistic, p.value, alternative) %>% 
	mutate(p.value = round(p.value, digits = 3))
```

All these variables are associated with the response variable. For this reason 
we will include them in the model for now.


# Build models


## Create data for testing H1 and H2

We can test H1 and H2 together, because data to test them are available in all
cities. The data for this model require collapsing of rows so that there are not
separate rows for offenses in public/private places.

```{r}
data_h1 <- data %>% 
	# mutate(city_name = ifelse(str_sub(geoid, 0, 5) == "36005", "Bronx", 
	# 													city_name)) %>% 
	filter(!city_name %in% c("Fort Worth")) %>%
	group_by(geoid, crime_type, period) %>% 
	summarise(
		count = sum(count),
		count_lag = sum(count_lag),
		city_name = first(city_name),
		school = first(school),
		schools = first(schools),
		students = first(students),
		elementary_school = first(elementary_school),
		elementary_schools = first(elementary_schools),
		elementary_students = first(elementary_students),
		secondary_school = first(secondary_school),
		secondary_schools = first(secondary_schools),
		secondary_students = first(secondary_students),
		private_elementary_school = first(private_elementary_school),
		private_elementary_schools = first(private_elementary_schools),
		private_elementary_students = first(private_elementary_students),
		public_elementary_school = first(public_elementary_school),
		public_elementary_schools = first(public_elementary_schools),
		public_elementary_students = first(public_elementary_students),
		private_secondary_school = first(private_secondary_school),
		private_secondary_schools = first(private_secondary_schools),
		private_secondary_students = first(private_secondary_students),
		public_secondary_school = first(public_secondary_school),
		public_secondary_schools = first(public_secondary_schools),
		public_secondary_students = first(public_secondary_students),
		pop_total = first(pop_total),
		pop_total_sc = first(pop_total_sc),
		index_disadvantage = first(index_disadvantage),
		index_mobility = first(index_mobility),
		index_ethnic = first(index_ethnic),
		perc_teen_sc = first(perc_teen_sc),
		prop_developed = first(prop_developed),
		prop_zoned_commercial_sc = first(prop_zoned_commercial_sc)
	) %>% 
	# we must ungroup() before mutate() otherwise dplyr will mutate by group
	ungroup() %>% 
	# the count_lag variable must be scaled or the model is unlikely to converge,
	# but this must be done after count_lag is summed
	# first() within summarise() appears to convert factors to character, but
	# grouping variables in glmer() must be factors, so city_name and period must
	# be converted back to factors
	mutate(
		count_lag_sc = as.numeric(scale(count_lag, center = TRUE, scale = TRUE)),
		city_name = as.factor(city_name), 
		period = as.factor(period),
		city_period = as.factor(paste0(city_name, " - ", period))
	) %>% 
	glimpse()
```


## Testing H1 and H2

The unit of analysis is the census block group. There are four records for each
block group for each crime type, one for each combination of school day and
school time. The data are therefore clustered in two ways, by city and by
period. The model must also control for socio-economic variables and for spatial
autocorrelation.

```{r}
mcmc_h1 <- read_rds("../analysis_data/mcmc_h1.Rds")
```


```{r H1 assault empty}
mcmc_h1$aslt_empty <- MCMCglmm::MCMCglmm(
	fixed = count ~ 1,
	random = ~ us(1):city_period,
	data = filter(as.data.frame(data_h1), crime_type == "assault"),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(1), n = 1)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	verbose = FALSE,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h1, "../analysis_data/mcmc_h1.Rds")
```


```{r H1 assault control}
mcmc_h1$aslt_control <- MCMCglmm::MCMCglmm(
	fixed = count ~ count_lag_sc,
	random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
									index_ethnic + perc_teen_sc):city_period,
	data = filter(as.data.frame(data_h1), crime_type == "assault"),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(6), n = 6)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	verbose = FALSE,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h1, "../analysis_data/mcmc_h1.Rds")
```


```{r H1 assault full}
mcmc_h1$aslt_full <- MCMCglmm::MCMCglmm(
	fixed = count ~ count_lag_sc,
	random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
									index_ethnic + perc_teen_sc + private_elementary_school +
									public_elementary_school + private_secondary_school + 
									public_secondary_school):city_period,
	data = filter(as.data.frame(data_h1), crime_type == "assault"),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(10), n = 10)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	verbose = FALSE,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h1, "../analysis_data/mcmc_h1.Rds")
```


```{r H1 assault compare models}
# this code from https://stackoverflow.com/a/31484507/8222654
MuMIn::model.sel(mcmc_h1$aslt_empty, mcmc_h1$aslt_control, mcmc_h1$aslt_full, 
								 rank = "DIC")
```


```{r H1 robbery empty}
mcmc_h1$robb_empty <- MCMCglmm::MCMCglmm(
	fixed = count ~ 1,
	random = ~ us(1):city_period,
	data = filter(as.data.frame(data_h1), crime_type == "robbery"),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(1), n = 1)
		)
	),
	thin = 40,
	burnin = 10000,
	nitt = 100000,
	verbose = FALSE,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h1, "../analysis_data/mcmc_h1.Rds")
```


```{r H1 robbery control}
mcmc_h1$robb_control <- MCMCglmm::MCMCglmm(
	fixed = count ~ count_lag_sc,
	random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
									index_ethnic + perc_teen_sc):city_period,
	data = filter(as.data.frame(data_h1), crime_type == "robbery"),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(6), n = 6)
		)
	),
	thin = 40,
	burnin = 10000,
	nitt = 100000,
	verbose = FALSE,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h1, "../analysis_data/mcmc_h1.Rds")
```


```{r H1 robbery full}
mcmc_h1$robb_full <- MCMCglmm::MCMCglmm(
	fixed = count ~ count_lag_sc,
	random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
									index_ethnic + perc_teen_sc + private_elementary_school +
									public_elementary_school + private_secondary_school + 
									public_secondary_school):city_period,
	data = filter(as.data.frame(data_h1), crime_type == "robbery", 
								!city_name %in% c("Kansas City", "Virginia Beach")),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(10), n = 10)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	verbose = FALSE,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h1, "../analysis_data/mcmc_h1.Rds")
```


```{r H1 robbery compare models}
# this code from https://stackoverflow.com/a/31484507/8222654
MuMIn::model.sel(mcmc_h1$robb_empty, mcmc_h1$robb_control, mcmc_h1$robb_full, 
								 rank = "DIC")
```


```{r MCMC autocorrelation check, fig.height=20, fig.width=7}


# par(mfrow = c(28, 2), mar = c(0.1, 0.1, 0.1, 0.1))
# plot(mcmc$robb$h3_full, ask = FALSE, auto.layout = FALSE)
```

```{r H1 Gelman tests}
mcmc_h1$aslt_full_gelman <- parallel::mclapply(1:4, function (i) {
	message("Starting iteration ", i, appendLF = TRUE)
	MCMCglmm::MCMCglmm(
		fixed = count ~ count_lag_sc,
		random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
										index_ethnic + perc_teen_sc + private_elementary_school +
										public_elementary_school + private_secondary_school + 
										public_secondary_school):city_period,
		data = filter(as.data.frame(data_h1), crime_type == "assault"),
		family = "poisson", # MCMC deals with over-dispersion
		prior = list(
			R = list(V = diag(1), nu = 0.002),
			G = list(
				G1 = list(V = diag(10), n = 10)
			)
		),
		thin = 20,
		burnin = 5000,
		nitt = 50000,
		verbose = FALSE,
		pr = TRUE # needed to output the estimates/CIs for the random effects
	)
})

write_rds(mcmc_h1, "../analysis_data/mcmc_h1.Rds")

mcmc_h1$robb_full_gelman <- parallel::mclapply(1:4, function (i) {
	message("Starting iteration ", i, appendLF = TRUE)
	MCMCglmm::MCMCglmm(
		fixed = count ~ count_lag_sc,
		random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
										index_ethnic + perc_teen_sc + private_elementary_school +
										public_elementary_school + private_secondary_school + 
										public_secondary_school):city_period,
		data = filter(as.data.frame(data_h1), crime_type == "robbery", 
									!city_name %in% c("Kansas City", "Virginia Beach")),
		family = "poisson", # MCMC deals with over-dispersion
		prior = list(
			R = list(V = diag(1), nu = 0.002),
			G = list(
				G1 = list(V = diag(10), n = 10)
			)
		),
		thin = 20,
		burnin = 5000,
		nitt = 50000,
		verbose = FALSE,
		pr = TRUE # needed to output the estimates/CIs for the random effects
	)
})

write_rds(mcmc_h1, "../analysis_data/mcmc_h1.Rds")

message("Finished processing data on ", now(), appendLF = TRUE)

mcmc_h1$robb_full_gelman %>% 
	map(function (x) x$Sol) %>% 
	{ do.call(coda::mcmc.list, .) } %>% 
	coda::gelman.diag() %>% 
	as.list() %>% 
	pluck("mpsrf")
```


```{r message=FALSE, warning=FALSE}
tidyMCMC(mcmc$aslt$h1_full_3hour$Sol, conf.int = TRUE) %>% 
	mutate_if(is.numeric, exp) %>% 
	separate(term, c("term", "city_period"), ".city_period.") %>% 
	# mutate(city_period = str_replace(city_period, coll(" - "), "//")) %>%
	separate(city_period, c("city", "period"), coll(" - ")) %>%
	separate(period, c("day", "time"), coll(" day ")) %>% 
	filter(term %in% c("private_elementary_schoolTRUE",
										 "public_elementary_schoolTRUE", 
										 "private_secondary_schoolTRUE", 
										 "public_secondary_schoolTRUE")) %>% 
	mutate(
		sig = ifelse(
			estimate > 1,
			ifelse(conf.low > 1, day, "non-sig"),
			ifelse(conf.high < 1, day, "non-sig")
		),
		term = str_replace_all(str_sub(term, 0, -5), "_", " ")
	) %>% 
	remove_missing(na.rm = TRUE) %>% 
	# mutate_if(is.character, factor) %>%
	# summary()
	ggplot(aes(x = time, colour = day)) +
	# geom_vline(xintercept = "08:00–08:59", colour = "#CCCCCC") +
	# geom_pointrange() is used here because geom_segment doesn't support vertical
	# dodging. The point is suppressed by setting fatten = 0 because the point
	# will be rendered separately with two calls to geom_point()
	geom_pointrange(aes(ymin = 1, y = 1, ymax = conf.low),
									position = position_dodge(width = 0.7), fatten = 0,
									linetype = "32", size = 0.25, alpha = 0.5) +
	geom_hline(yintercept = 1) +
	geom_pointrange(aes(ymin = conf.low, y = estimate, ymax = conf.high),
							 position = position_dodge(width = 0.7), fatten = 0) +
	# the first point represents significance using fill
	geom_point(aes(y = estimate, fill = sig), shape = 21,
						 position = position_dodge(width = 0.7)) +
	# the second point represents school/non-school day using the outline colour
	geom_point(aes(y = estimate), fill = NA, shape = 21,
						 position = position_dodge(width = 0.7)) +
	# geom_pointrange(position = position_dodge(width = 0.3), shape = 21,
	# 								fatten = 1.5) +
	scale_x_discrete(position = "top") +
	scale_y_continuous(trans = "log", expand = c(0, 0), 
										 labels = scales::number_format(accuracy = 0.1)) +
	scale_colour_manual(
		values = c("#666666", "#000000")
	) +
	scale_fill_manual(
		values = c("non-school" = "#666666", "school" = "#000000", 
							 "non-sig" = "#FFFFFF")
	) +
	# scale_linetype_manual(values = c("dashed", "solid")) +
	coord_flip() +
	facet_grid(rows = vars(city), cols = vars(term), switch = "y") +
	theme_minimal() +
	theme(
		axis.title = element_blank(),
		axis.ticks = element_line(colour = "grey92"),
		panel.grid.major.y = element_blank(),
		panel.grid.minor.y = element_blank(),
		strip.text.y = element_text(angle = -90),
		legend.position = "bottom"
	)
```

```{r H1 distribution chart, fig.height=9.21, fig.width=6.85}

# figure size from https://www.springer.com/gp/authors-editors/journal-author/journal-author-helpdesk/manuscript-preparation/1260

plot_labels <- c(
			`non-school day` = " non-school weekday   \n 07:00–18:59", 
			`non-school night` = " non-school weekday   \n 19:00–06:59", 
			`school day` = " school weekday   \n 07:00–18:59", 
			`school night` = " school weekday   \n 19:00–06:59"
)

plot_data <- pluck(mcmc_h1$robb_full, "Sol") %>% 
	as.tibble() %>% 
	gather() %>% 
	separate(key, c("term", "city_period"), ".city_period.") %>% 
	separate(city_period, c("city", "period"), coll(" - ")) %>%
	separate(period, c("day", "time"), coll(" day ")) %>% 
	filter(term %in% c("private_elementary_schoolTRUE",
										 "public_elementary_schoolTRUE", 
										 "private_secondary_schoolTRUE", 
										 "public_secondary_schoolTRUE")) %>% 
	remove_missing(na.rm = TRUE) %>% 
	mutate(
		term = str_replace_all(str_sub(term, 0, -5), "_", " "),
		period = paste(day, ifelse(time == "school time", "day", "night")),
		period = factor(period, levels = c("school day", "non-school day", 
																			 "school night", "non-school night")),
		value = exp(value)
	)

plot_means <- plot_data %>% 
	group_by(term, city, period) %>% 
	summarise(mean_value = mean(value)) %>% 
	filter(period == "school day")

# plot_tests <- plot_data %>% 
# 	select(-day, -time) %>% 
# 	nest(-term, -city) %>% 
# 	mutate(
# 		anova_result = map(data, function (x) {
# 			result <- tidy(aov(value ~ period, data = x))
# 			c(
# 				statistic = result[[1, "statistic"]],
# 				p = result[[1, "p.value"]],
# 				df = result[[1, "df"]],
# 				df_res = result[[2, "df"]]
# 			)
# 		}),
# 		anova_p = map_dbl(anova_result, function (x) {
# 			pluck(x, "p")
# 		})
# 	)

plot_cities <- plot_means %>% 
	filter(term == "public secondary school") %>% 
	arrange(desc(mean_value)) %>% 
	pluck("city")

dist_plot <- plot_data %>% 
	mutate(city = factor(city, levels = plot_cities)) %>% 
	ggplot(aes(x = value)) + 
	geom_vline(xintercept = 1, colour = "grey60") +
	geom_density(aes(colour = period, fill = period, linetype = period), size = 1, 
							 trim = TRUE) +
	geom_vline(aes(xintercept = mean_value), data = plot_means) +
	geom_label(aes(x = mean_value, y = 10, label = round(mean_value, 2)), 
						 label.size = NA, size = 2.5, data = plot_means) +
	geom_hline(yintercept = 0, colour = "grey92", size = 0.25) + 
	scale_x_continuous(limits = c(1/3, 3), expand = c(0, 0), trans = "log", 
										 breaks = c(1/2, 1, 2),
										 labels = scales::number_format(accuracy = 0.1)) +
	scale_y_continuous(expand = c(0, 0)) +
	scale_colour_manual(
		values = c(
			`non-school day` = "#999999", 
			`non-school night` = "#999999", 
			`school day` = "#000000", 
			`school night` = "#000000"
		),
		labels = plot_labels
	) +
	scale_fill_manual(
		values = c(
			`non-school day` = NA, 
			`non-school night` = NA, 
			`school day` = "#CCCCCC", 
			`school night` = NA
		),
		labels = plot_labels
	) +
	scale_linetype_manual(
		values = c(
			`non-school day` = "solid", 
			`non-school night` = "23", 
			`school day` = "solid", 
			`school night` = "23"
		),
		labels = plot_labels
	) +
	guides(
		colour = guide_legend("school"), 
		fill = guide_legend("school"),
		linetype = guide_legend("school")
	) +
	labs(x = "odds ratio (log scale)") +
	facet_grid(rows = vars(city), cols = vars(term), switch = "y") +
	theme_minimal() +
	theme(
		axis.ticks.x = element_line(colour = "grey92"),
		axis.title.y = element_blank(),
		axis.text.y = element_blank(),
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank(),
		strip.text.y = element_text(angle = -90),
		legend.title = element_blank(),
		legend.position = "bottom"
	)

plot_x_axis_lims <- ggplot_build(dist_plot)$layout$panel_params[[1]]

dist_plot

rm(plot_cities, plot_data, plot_labels, plot_means)
```



## Create data for testing H3

To produce data for testing H3, the original data must be filtered to exclude
crimes:

  * in cities for which location types are not available,
  * in locations that are not clearly public or clearly private, and
  * at night or on non-school days.

```{r}
data_h3 <- data %>%
	filter(
		city_name != "Fort Worth",
		public_location != "other",
		school_day == TRUE,
		school_time == TRUE
	) %>% 
	mutate(
		count_lag_sc = as.numeric(scale(count_lag, center = TRUE, scale = TRUE)),
		city_location = as.factor(paste0(city_name, " - ", public_location))
	) %>% 
	glimpse()
```


## Testing H3

The unit of analysis is again the census block group. There are two records for
each block group for each crime type, one for public crimes and one for private
crimes.

```{r}
mcmc_h3 <- read_rds("../analysis_data/mcmc_h3.Rds")
```


```{r H3 assault empty}
mcmc_h3$robb_empty <- MCMCglmm::MCMCglmm(
	fixed = count ~ 1,
	random = ~ us(1):city_period,
	data = filter(as.data.frame(data_h3), crime_type == "assault"),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(10), n = 10)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h3, "../analysis_data/mcmc_h3.Rds")
```


```{r H3 assault control}
mcmc_h3$robb_control <- MCMCglmm::MCMCglmm(
	fixed = count ~ count_lag_sc,
	random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
									index_ethnic + perc_teen_sc):city_location,
	data = filter(as.data.frame(data_h3), crime_type == "assault"),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(10), n = 10)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h3, "../analysis_data/mcmc_h3.Rds")
```


```{r H3 assault full}
mcmc_h3$robb_full <- MCMCglmm::MCMCglmm(
	fixed = count ~ count_lag_sc,
	random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
									index_ethnic + perc_teen_sc + private_elementary_school +
									public_elementary_school + private_secondary_school + 
									public_secondary_school):city_location,
	data = filter(as.data.frame(data_h3), crime_type == "assault"),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(10), n = 10)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h3, "../analysis_data/mcmc_h3.Rds")
```


```{r H3 assault compare models}
# this code from https://stackoverflow.com/a/31484507/8222654
MuMIn::model.sel(mcmc_h3$aslt_empty, mcmc_h3$aslt_control, mcmc_h3$aslt_full, 
								 rank = "DIC")
```


```{r H3 robbery empty}
mcmc_h3$robb_control <- MCMCglmm::MCMCglmm(
	fixed = count ~ 1,
	random = ~ us(1):city_period,
	data = filter(as.data.frame(data_h3), crime_type == "robbery", 
									!city_name %in% c("Kansas City", "Virginia Beach")),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(10), n = 10)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h3, "../analysis_data/mcmc_h3.Rds")
```


```{r H3 robbery control}
mcmc_h3$robb_control <- MCMCglmm::MCMCglmm(
	fixed = count ~ count_lag_sc,
	random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
									index_ethnic + perc_teen_sc):city_location,
	data = filter(as.data.frame(data_h3), crime_type == "robbery", 
									!city_name %in% c("Kansas City", "Virginia Beach")),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(10), n = 10)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h3, "../analysis_data/mcmc_h3.Rds")
```


```{r H3 robbery full}
mcmc_h3$robb_full <- MCMCglmm::MCMCglmm(
	fixed = count ~ count_lag_sc,
	random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
									index_ethnic + perc_teen_sc + private_elementary_school +
									public_elementary_school + private_secondary_school + 
									public_secondary_school):city_location,
	data = filter(as.data.frame(data_h3), crime_type == "robbery", 
									!city_name %in% c("Kansas City", "Virginia Beach")),
	family = "poisson", # MCMC deals with over-dispersion
	prior = list(
		R = list(V = diag(1), nu = 0.002),
		G = list(
			G1 = list(V = diag(10), n = 10)
		)
	),
	thin = 20,
	burnin = 5000,
	nitt = 50000,
	pr = TRUE # needed to output the estimates/CIs for the random effects
)

paste("Finished processing data on", now())

write_rds(mcmc_h3, "../analysis_data/mcmc_h3.Rds")
```


```{r H3 robbery compare models}
# this code from https://stackoverflow.com/a/31484507/8222654
MuMIn::model.sel(mcmc_h3$robb_empty, mcmc_h3$robb_control, mcmc_h3$robb_full, 
								 rank = "DIC")
```


```{r H3 Gelman checks}

mcmc_h3$aslt_full_gelman <- parallel::mclapply(1:4, function (i) {
	message("Starting iteration ", i, appendLF = TRUE)
	MCMCglmm::MCMCglmm(
		fixed = count ~ count_lag_sc,
		random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
										index_ethnic + perc_teen_sc + private_elementary_school +
										public_elementary_school + private_secondary_school + 
										public_secondary_school):city_location,
		data = filter(as.data.frame(data_h3), crime_type == "assault"),
		family = "poisson", # MCMC deals with over-dispersion
		prior = list(
			R = list(V = diag(1), nu = 0.002),
			G = list(
				G1 = list(V = diag(10), n = 10)
			)
		),
		thin = 20,
		burnin = 5000,
		nitt = 50000,
		verbose = FALSE,
		pr = TRUE # needed to output the estimates/CIs for the random effects
	)
})

write_rds(mcmc_h3, "../analysis_data/mcmc_h3.Rds")

mcmc_h3$aslt_full_gelman %>% 
	map(function (x) x$Sol) %>% 
	{ do.call(coda::mcmc.list, .) } %>% 
	coda::gelman.diag() %>% 
	as.list() %>% 
	pluck("mpsrf")

mcmc_h3$robb_full_gelman <- parallel::mclapply(1:4, function (i) {
	message("Starting iteration ", i, appendLF = TRUE)
	MCMCglmm::MCMCglmm(
		fixed = count ~ count_lag_sc,
		random = ~ us(1 + pop_total_sc + index_disadvantage + index_mobility + 
										index_ethnic + perc_teen_sc + private_elementary_school +
										public_elementary_school + private_secondary_school + 
										public_secondary_school):city_location,
		data = filter(as.data.frame(data_h3), crime_type == "robbery", 
									!city_name %in% c("Kansas City", "Virginia Beach")),
		family = "poisson", # MCMC deals with over-dispersion
		prior = list(
			R = list(V = diag(1), nu = 0.002),
			G = list(
				G1 = list(V = diag(10), n = 10)
			)
		),
		thin = 20,
		burnin = 5000,
		nitt = 50000,
		verbose = FALSE,
		pr = TRUE # needed to output the estimates/CIs for the random effects
	)
})

write_rds(mcmc_h3, "../analysis_data/mcmc_h3.Rds")

message("Finished processing data on ", now(), appendLF = TRUE)

mcmc_h3$robb_full_gelman %>% 
	map(function (x) x$Sol) %>% 
	{ do.call(coda::mcmc.list, .) } %>% 
	coda::gelman.diag() %>% 
	as.list() %>% 
	pluck("mpsrf")
```


```{r H3 distribution chart, fig.height=4.6, fig.width=6.85}

# figure size from https://www.springer.com/gp/authors-editors/journal-author/journal-author-helpdesk/manuscript-preparation/1260

plot_labels <- c(
			`private` = " private location   ", 
			`public` = " public location   "
)

plot_data <- pluck(mcmc_h3$robb_full, "Sol") %>%
	as.tibble() %>% 
	gather() %>% 
	separate(key, c("term", "city_location"), ".city_location.") %>% 
	separate(city_location, c("city", "location"), coll(" - ")) %>%
	filter(term %in% c("private_elementary_schoolTRUE",
										 "public_elementary_schoolTRUE", 
										 "private_secondary_schoolTRUE", 
										 "public_secondary_schoolTRUE")) %>% 
	remove_missing(na.rm = TRUE) %>% 
	mutate(
		location = factor(location, levels = c("public", "private")),
		term = str_replace_all(str_sub(term, 0, -5), "_", " "),
		value = exp(value)
	)

plot_means <- plot_data %>% 
	group_by(term, city, location) %>% 
	summarise(mean_value = mean(value)) %>% 
	filter(location == "public")

# plot_tests <- plot_data %>% 
# 	select(-day, -time) %>% 
# 	nest(-term, -city) %>% 
# 	mutate(
# 		anova_result = map(data, function (x) {
# 			result <- tidy(aov(value ~ period, data = x))
# 			c(
# 				statistic = result[[1, "statistic"]],
# 				p = result[[1, "p.value"]],
# 				df = result[[1, "df"]],
# 				df_res = result[[2, "df"]]
# 			)
# 		}),
# 		anova_p = map_dbl(anova_result, function (x) {
# 			pluck(x, "p")
# 		})
# 	)

plot_cities <- plot_means %>% 
	filter(term == "public secondary school") %>% 
	arrange(desc(mean_value)) %>% 
	pluck("city")

dist_plot <- plot_data %>% 
	mutate(city = factor(city, levels = plot_cities)) %>% 
	ggplot(aes(x = value)) + 
	geom_vline(xintercept = 1, colour = "grey60") +
	geom_density(aes(colour = location, fill = location), size = 1, trim = TRUE) +
	geom_vline(aes(xintercept = mean_value), data = plot_means) +
	geom_label(aes(x = mean_value, y = 10, label = round(mean_value, 2)), 
						 label.size = NA, size = 2.5, data = plot_means) +
	geom_hline(yintercept = 0, colour = "grey92", size = 0.25) + 
	scale_x_continuous(limits = c(1/3, 3), 
										 expand = c(0, 0), trans = "log", 
										 # breaks = c(1/2, 1, 2),
										 labels = scales::number_format(accuracy = 0.1)) +
	scale_y_continuous(expand = c(0, 0)) +
	scale_colour_manual(
		values = c(
			`private` = "#999999", 
			`public` = "#000000"
		),
		labels = plot_labels
	) +
	scale_fill_manual(
		values = c(
			`private` = NA, 
			`public` = "#CCCCCC" 
		),
		labels = plot_labels
	) +
	guides(
		colour = guide_legend("school"), 
		fill = guide_legend("school")
	) +
	labs(x = "odds ratio (log scale)") +
	facet_grid(rows = vars(city), cols = vars(term), switch = "y") +
	theme_minimal() +
	theme(
		axis.ticks.x = element_line(colour = "grey92"),
		axis.title.y = element_blank(),
		axis.text.y = element_blank(),
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank(),
		strip.text.y = element_text(angle = -90),
		legend.title = element_blank(),
		legend.position = "bottom"
	)

# plot_x_axis_lims <- ggplot_build(dist_plot)$layout$panel_params[[1]]

dist_plot

# rm(plot_cities, plot_data, plot_labels, plot_means)
```
