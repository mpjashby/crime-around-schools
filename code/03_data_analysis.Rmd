---
title: "Data analysis"
output: 
  html_notebook
---


# Hypotheses

We wish to test hypotheses relating to how routine activities of school
students influence crime in surrounding areas. Specifically, if school students'
activities cause increases in crime, we would expect:

  * H1: high/middle schools to be associated with more violence at schools times 
    on school weekdays but not on vacation weekdays or at non-school times,
  * H2: high/middle schools to be associated with more violence but elementary
    schools not to be,
  * H3: high schools to be associated with more violence on streets and against 
    some types of business but not more violence in dwellings,


# Read data

The data are already in the required format because data cleaning has been done,
so they can just be read directly from the RDS file.

```{r}
data <- read_rds("../analysis_data/blockgroup_data.Rds") %>% 
	glimpse()
```


# Check data

We can check in detail that the data meets our expectations. This is done in 
this file rather than the data cleaning file in case any problems have been
introduced while saving and loading the data as a CSV.

```{r}
data %>% 
	
	# characters
	assert(is.character, geoid) %>% 
	assert(not_na, geoid) %>% 
	print_comment("ðŸ‘ geoid is a character with no NA values") %>% 

	# characters with specific values
	assert(is.character, city_name) %>% 
	assert(in_set(cities$name), city_name) %>% 
	assert(not_na, city_name) %>% 
	print_comment("ðŸ‘ city_name is a character, all values are valid CODE cities",
								"with no NA values") %>% 
	assert(is.character, public_location) %>% 
	assert(in_set("public", "private", "other"), public_location) %>% 
	assert(not_na, public_location) %>%
	print_comment("ðŸ‘ public_location is a character, all values are valid with",
								"no NA values") %>% 

	# positive integers
	assert(is.integer, count, schools, students, private_elementary_schools, 
				 private_secondary_schools, public_elementary_schools, 
				 public_secondary_schools, private_elementary_students, 
				 private_secondary_students, public_elementary_students, 
				 public_secondary_students, elementary_schools, secondary_schools, 
				 elementary_students, secondary_students, pop_total) %>% 
	assert(within_bounds(0, Inf), count, schools, students, 
				 private_elementary_schools, private_secondary_schools, 
				 public_elementary_schools, public_secondary_schools, 
				 private_elementary_students, private_secondary_students, 
				 public_elementary_students, public_secondary_students, 
				 elementary_schools, secondary_schools, elementary_students, 
				 secondary_students, pop_total) %>% 
	assert(not_na, count, schools, students, private_elementary_schools, 
				 private_secondary_schools, public_elementary_schools, 
				 public_secondary_schools, private_elementary_students, 
				 private_secondary_students, public_elementary_students, 
				 public_secondary_students, elementary_schools, secondary_schools, 
				 elementary_students, secondary_students, pop_total) %>% 
	print_comment("ðŸ‘ count, schools, students, private_elementary_schools,", 
								"private_secondary_schools, public_elementary_schools,",
								"public_secondary_schools, private_elementary_students,", 
								"private_secondary_students, public_elementary_students,", 
								"public_secondary_students, elementary_schools,", 
								"secondary_schools, elementary_students, secondary_students",
								"and pop_total are positive integers with no NA values") %>% 
	
	# doubles
	assert(is.double, index_disadvantage, index_mobility, index_ethnic,
				 perc_teen_sc, prop_zoned_commercial_sc) %>%
	assert(not_na, index_disadvantage, index_mobility, index_ethnic,
				 perc_teen_sc, prop_zoned_commercial_sc) %>%
	print_comment("ðŸ‘ index_disadvantage, index_mobility, index_ethnic,",
								"perc_teen_sc and prop_zoned_commercial_sc are doubles with no",
								"NA values") %>% 

	# doubles between zero and one
	assert(is.double, prop_developed, land_cover_prop_22, land_cover_prop_23,
				 land_cover_prop_24, prop_zoned_commercial) %>%
	assert(within_bounds(0, 1), prop_developed, land_cover_prop_22,
				 land_cover_prop_23, land_cover_prop_24, prop_zoned_commercial) %>%
	print_comment("ðŸ‘ prop_developed, land_cover_prop_22, land_cover_prop_23,",
								"land_cover_prop_24 and prop_zoned_commercial are doubles",
								"between 0 and 1 with no NA values") %>% 

	# positive doubles
	assert(is.double, area_land, area_water, count_lag) %>% 
	assert(within_bounds(0, Inf), area_land, area_water, count_lag) %>% 
	assert(not_na, area_land, area_water, count_lag) %>% 
	print_comment("ðŸ‘ area_land, area_water, pop_density and count_lag are",
								"positive doubles with no NA values") %>% 

	# factors
	assert(is.factor, crime_type, period) %>% 
	assert(not_na, crime_type, period) %>%
	print_comment("ðŸ‘ crime_type and period are factors with no NA values") %>% 
	assert(in_set("non-school day, school time", "school day, non-school time", 
								"non-school day, non-school time", "school day, school time"), 
				 period) %>% 
	print_comment("ðŸ‘ all values of period are valid") %>% 

	# logicals
	assert(is.logical, school_day, school_time, school) %>% 
	# assert(not_na, school_day, school_time, school) %>% 
	print_comment("ðŸ‘ school_day, school_time and school are logical with no NA",
								"values") %>% 

	glimpse()
```


# Select a model type

Since the dependent variable is a count of crimes, we expect the data to have an
overdispersed Poisson (i.e. negative binomial) distribution. This can be checked
visually and by calculating the ratio of the variance of the dependent variable
to the mean.

```{r}
data %>% 
	mutate(label = str_replace_all(period, ", ", "\n")) %>% 
	ggplot() + geom_histogram(aes(count), bins = 100) + 
	facet_grid(cols = vars(crime_type), rows = vars(label)) + 
	theme_minimal() +
	theme(strip.text.y = element_text(angle = 0))
```

The histograms suggest a Poisson-distributed response variable. We can check
the var/mean ratio to see if it is over-dispersed.

```{r}
data %>% 
	group_by(crime_type) %>% 
	summarise(cov = var(count) / mean(count))
```

We can see the variance is much greater than the mean, so (as expected) the 
response variable is overdispersed. Thus a NB model approach looks reasonable, 
subject to tests of the resulting models.

The histograms suggest some outlier blockgroups. We can identify these:

```{r}
data %>% 
	filter(count > 300, prop_zoned_commercial < 0.5)
```



# Descriptive analysis

## Schools

```{r}
data %>% 
	group_by(city_name, school) %>% 
	summarise(n = n()) %>% 
	spread(school, n) %>% 
	mutate(prop_with_schools = round(`TRUE` / (`TRUE` + `FALSE`), digits = 3))
```


# Test assumptions

In the models we control for disadvantage, population turnover, ethnic 
heterogeneity and the proportion of the population who are teenagers. To see if 
this is necessary, we can test whether places with schools are different in 
these respects to places without schools.

```{r}
map_df(
	c("index_disadvantage", "index_mobility", "index_ethnic", "perc_teen_sc", 
		"prop_developed", "prop_zoned_commercial"), 
	function (x) {
		wilcox.test(as.formula(paste(x, "~ school")), data = data) %>% 
			tidy() %>% 
			mutate(test = paste("Wilcoxcon: ", x, "~ school"))
	}) %>%
	select(test, statistic, p.value, alternative) %>% 
	mutate(p.value = round(p.value, digits = 3))
```

All these variables are associated with the response variable. For this reason 
we will include them in the model for now.


# Build models

We will store all the models in a single list containing a list for each type of
crime. We can also initiate a list for formulae.

```{r}
f <- list()

m <- read_rds("../analysis_data/models.Rds")

ci <- list(
	"aslt" = list(),
	"robb" = list()
)
```

## Create data for testing H1 and H2

We can test H1 and H2 together, because data to test them are available in all
cities. The data for this model require collapsing of rows so that there are not
separate rows for offenses in public/private places.

```{r}
data_h1 <- data %>% 
	mutate(city_name = ifelse(str_sub(geoid, 0, 5) == "36005", "Bronx", 
														city_name)) %>% 
	filter(!city_name %in% c("Fort Worth", "New York")) %>% 
	group_by(geoid, crime_type, period) %>% 
	summarise(
		count = sum(count),
		count_lag = sum(count_lag),
		city_name = first(city_name),
		school = first(school),
		schools = first(school_count),
		students = first(school_students),
		elementary_school = first(elementary_school),
		elementary_schools = first(elementary_schools),
		elementary_students = first(elementary_students),
		secondary_school = first(secondary_school),
		secondary_schools = first(secondary_schools),
		secondary_students = first(secondary_students),
		private_elementary_school = first(private_elementary_school),
		private_elementary_schools = first(private_elementary_schools),
		private_elementary_students = first(private_elementary_students),
		public_elementary_school = first(public_elementary_school),
		public_elementary_schools = first(public_elementary_schools),
		public_elementary_students = first(public_elementary_students),
		private_secondary_school = first(private_secondary_school),
		private_secondary_schools = first(private_secondary_schools),
		private_secondary_students = first(private_secondary_students),
		public_secondary_school = first(public_secondary_school),
		public_secondary_schools = first(public_secondary_schools),
		public_secondary_students = first(public_secondary_students),
		pop_total = first(pop_total),
		pop_total_sc = first(pop_total_sc),
		index_disadvantage = first(index_disadvantage),
		index_mobility = first(index_mobility),
		index_ethnic = first(index_ethnic),
		perc_teen_sc = first(perc_teen_sc),
		prop_developed = first(prop_developed),
		prop_zoned_commercial_sc = first(prop_zoned_commercial_sc)
	) %>% 
	# we must ungroup() before mutate() otherwise dplyr will mutate by group
	ungroup() %>% 
	# the count_lag variable must be scaled or the model is unlikely to converge,
	# but this must be done after count_lag is summed
	# first() within summarise() appears to convert factors to character, but
	# grouping variables in glmer() must be factors, so city_name and period must
	# be converted back to factors
	mutate(
		count_lag_sc = as.numeric(scale(count_lag, center = TRUE, scale = TRUE)),
		city_name = as.factor(city_name), 
		period = as.factor(period)
	) %>% 
	glimpse()
```


## Testing H1 and H2

The unit of analysis is the census block group. There are four records for each
block group for each crime type, one for each combination of school day and 
school time. The data are therefore clustered in two (non-nested) ways, by city 
and by period. The model must also control for socio-economic variables and for 
spatial autocorrelation.

```{r}
f$h1 <- count ~ count_lag_sc + (pop_total_sc + index_disadvantage + 
	index_mobility + index_ethnic + perc_teen_sc + prop_zoned_commercial_sc + 
	private_elementary_school + public_elementary_school + 
	private_secondary_school + public_secondary_school | period) + 
	(school | city_name)

system.time(
	m$aslt$h1_sample <- glmer.nb(
		f$h1, 
		data = data_h1 %>% 
			filter(crime_type == "assault") %>% 
			group_by(city_name) %>% 
			sample_frac(0.05) %>% 
			ungroup(),
		control = glmerControl(optCtrl = list(maxfun = 10^7), calc.derivs = FALSE)
	)
)

write_rds(m, "../analysis_data/models.Rds")
```

## Post-hoc tests

Tests for independence of residuals etc

Consider Legrange Multiplier test for residual spatial autocorrelation


